---
tags:
- Free Software
- 'GNU+Linux'
- HOWTO
- железки
title: 'X.org 1.8'
---

[Когда-то][] в X.org добавили поддержку [HAL][], чтобы сервер мог на
ходу подключать и отключать устройства ввода. Через XML-файлики
настройки HAL можно было прописать присваивание нужных значений условным
параметрам девайса, после чего X-сервер мог этот девайс задействовать в
работе:

    <match key="info.capabilities" contains="input.keyboard">
      <merge key="input.x11_driver" type="string">evdev</merge>
      …

С версии 1.8 в файлах настройки X.org можно и нужно использовать udev
вместо HAL и более читабельный синтаксис для гибкой настройки устройств
ввода:

    Section "InputClass"
        Identifier "kb"
        MatchIsKeyboard "yes"
        Driver "evdev"
        Option "XkbModel" "evdev"
        Option "XkbLayout" "us,ru"
        Option "XkbVariant" ",winkeys"
        Option "XkbOptions" "grp_led:caps,compose:ralt"
    EndSection

Вся магия — в опциях `Match…`: при их указании настройки данной секции
`InputClass` применяются ко всем устройствам, удовлетворяющим
соответствующему условию. `MatchIsKeyboard "yes"` означает «для любых
клавиатур». Далее я просто указываю нужные опции для клавиатуры.

Также теперь можно разносить конфиг иксов по нескольким файлам: при
загрузке сервера читается не только `/etc/X11/xorg.conf`, но и файлы с
расширением `.conf` из директории `/etc/X11/xorg.conf.d/`.

## Как это работает

Начиная с версии [148][] в udev содержится код (перенесённый из HAL,
кстати), который присваивает устройствам ввода на уровне udev
специальные метки типа `ID_INPUT_KEY`, `ID_INPUT_MOUSE` или
`ID_INPUT_TABLET`. X.org может читать эти метки, за счёт чего указание в
конфигурации иксов секций `InputClass` с определёнными опциями вроде
`MatchIsKey` или `MatchIsPointer` позволяет назначать железкам с этими
метками нужные настройки.

## Ретроспектива

Таким образом, за последние годы X.org прошёл примерно следующий путь:

-   Написание секций `InputDevice` для каждого устройства ввода вручную.
    При использовании старого драйвера клавиатуры `kbd(4x)` минусом было
    то, что каждая секция привязывалась к одному физическому устройству
    с помощью опции `Device`. Не было поддержки подключения на лету, а
    самое главное — для клавиатур, которым соответствует несколько
    устройств (например, [MS NEK 4000][Когда-то]), нельзя было написать
    одну секцию. В результате приходилось дублировать информацию.

-   Чтобы избавиться от необходимости жёстко прописывать путь к
    устройству ввода (`/dev/input/что-у-вас-там/`), в универсальном
    драйвере `evdev(4x)` некоторое время была возможность искать
    устройство по производителю или названию модели прямо с помощью
    опций самого драйвера: `Option "vendor"` и `Option "name"`. Смысла в
    в реальном названии устройства куда больше, чем в пути к файлу из
    `/dev`, но реализация этого механизма на уровне конкретного драйвера
    была сомнительным решением. На данный момент этих фич там уже нет.

-   Появилась возможность работать с HAL. Настройка ввода, по сути,
    выполнялась полностью средствами HAL через XML-файлы `.fdi`. Можно
    было назначать специальные опции, которые потом читались иксами,
    *всем* устройствам с нужными свойствами, вроде производителя
    (`<match key="info.vendor" contains="Microsoft">`) или
    «возможностей»
    (`<match key="info.capabilities" contains="input.mouse">`). HAL
    пытался решать сходные с udev задачи и сдох под тяжестью
    собственного веса.

-   Наконец, появились секции `InputClass`, стало можно описывать нужное
    подмножество устройств прямо на уровне X.org.

  [Когда-то]: http://dzhus.org/blog/entry/msnek-linux
  [HAL]: hal
  [148]: http://git.kernel.org/?p=linux/hotplug/udev.git;a=commit;h=a6cf7734015dfc4479f4fdd4585d8953979fe0b0
